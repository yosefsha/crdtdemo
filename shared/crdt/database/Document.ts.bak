// Document: A sync unit containing multiple collections
// Documents are the unit of synchronization in the CRDT system

import { Collection, CollectionDelta } from "./Collection";
import { AgentId, ReplicaId, ItemId } from "./CRDTItem";

export type DocumentId = string;
export type CollectionId = string;

/**
 * Delta packet for a document, containing deltas from multiple collections
 */
export interface DocumentDeltaPacket<T = any> {
  documentId: DocumentId;
  collectionDeltas: Record<CollectionId, CollectionDelta<T>[]>;
  fromReplica: ReplicaId;
  fromAgent: AgentId;
}

/**
 * Merge result indicating what was applied and what's missing
 */
export interface DocumentMergeResult<T = any> {
  applied: Record<CollectionId, CollectionDelta<T>[]>;
  missing: Record<CollectionId, CollectionDelta<T>[]>;
}

/**
 * A document containing multiple named collections
 * Documents are the unit of synchronization
 */
export class Document<T = any> {
  private documentId: DocumentId;
  private collections: Map<CollectionId, Collection<T>>;

  // Vector clocks for tracking what each agent/replica has seen
  // For each collection and item, track the last timestamp seen from each agent
  private agentTimestamps: Map<AgentId, Map<CollectionId, Map<ItemId, number>>>;
  private replicaTimestamps: Map<
    ReplicaId,
    Map<CollectionId, Map<ItemId, number>>
  >;

  constructor(documentId: DocumentId) {
    this.documentId = documentId;
    this.collections = new Map();
    this.agentTimestamps = new Map();
    this.replicaTimestamps = new Map();
  }

  /**
   * Get the document ID
   */
  getDocumentId(): DocumentId {
    return this.documentId;
  }

  /**
   * Get or create a collection
   */
  getCollection(collectionId: CollectionId): Collection<T> {
    let collection = this.collections.get(collectionId);
    if (!collection) {
      collection = new Collection<T>(collectionId);
      this.collections.set(collectionId, collection);
    }
    return collection;
  }

  /**
   * Check if a collection exists
   */
  hasCollection(collectionId: CollectionId): boolean {
    return this.collections.has(collectionId);
  }

  /**
   * Get all collection IDs
   */
  getAllCollectionIds(): CollectionId[] {
    return Array.from(this.collections.keys());
  }

  /**
   * Set an item in a collection
   * Automatically creates the collection if it doesn't exist
   */
  setItem(
    collectionId: CollectionId,
    itemId: ItemId,
    value: T | null,
    timestamp: number,
    replicaId: ReplicaId,
    agentId: AgentId
  ): CollectionDelta<T> | null {
    const collection = this.getCollection(collectionId);
    const delta = collection.setItem(
      itemId,
      value,
      timestamp,
      replicaId,
      agentId
    );

    // Update vector clocks if delta was applied
    if (delta) {
      this.updateVectorClock(
        collectionId,
        itemId,
        timestamp,
        agentId,
        replicaId
      );
    }

    return delta;
  }

  /**
   * Get an item from a collection
   */
  getItem(collectionId: CollectionId, itemId: ItemId): T | null {
    const collection = this.collections.get(collectionId);
    return collection ? collection.getItem(itemId) : null;
  }

  /**
   * Update vector clocks when an item is updated
   */
  private updateVectorClock(
    collectionId: CollectionId,
    itemId: ItemId,
    timestamp: number,
    agentId: AgentId,
    replicaId: ReplicaId
  ): void {
    // Update agent timestamp
    if (!this.agentTimestamps.has(agentId)) {
      this.agentTimestamps.set(agentId, new Map());
    }
    const agentCollections = this.agentTimestamps.get(agentId)!;
    if (!agentCollections.has(collectionId)) {
      agentCollections.set(collectionId, new Map());
    }
    const agentItems = agentCollections.get(collectionId)!;
    agentItems.set(itemId, timestamp);

    // Update replica timestamp
    if (!this.replicaTimestamps.has(replicaId)) {
      this.replicaTimestamps.set(replicaId, new Map());
    }
    const replicaCollections = this.replicaTimestamps.get(replicaId)!;
    if (!replicaCollections.has(collectionId)) {
      replicaCollections.set(collectionId, new Map());
    }
    const replicaItems = replicaCollections.get(collectionId)!;
    replicaItems.set(itemId, timestamp);
  }

  /**
   * Get deltas for an agent (inter-agent sync)
   */
  getDeltasForAgent(agentId: AgentId): DocumentDeltaPacket<T> | null {
    const collectionDeltas: Record<CollectionId, CollectionDelta<T>[]> = {};
    const agentCollections = this.agentTimestamps.get(agentId) || new Map();

    this.collections.forEach((collection, collectionId) => {
      const agentItems = agentCollections.get(collectionId) || new Map();
      const deltas = collection.getDeltasSince(agentItems);

      if (deltas.length > 0) {
        collectionDeltas[collectionId] = deltas;
      }
    });

    if (Object.keys(collectionDeltas).length === 0) {
      return null;
    }

    return {
      documentId: this.documentId,
      collectionDeltas,
      fromReplica: "", // Will be set by caller
      fromAgent: "", // Will be set by caller
    };
  }

  /**
   * Get deltas for a replica (intra-agent sync)
   */
  getDeltasForReplica(replicaId: ReplicaId): DocumentDeltaPacket<T> | null {
    const collectionDeltas: Record<CollectionId, CollectionDelta<T>[]> = {};
    const isNewReplica = !this.replicaTimestamps.has(replicaId);

    // If this is a new replica and we have collections, return all deltas
    if (isNewReplica && this.collections.size > 0) {
      this.collections.forEach((collection, collectionId) => {
        const deltas = collection.getAllDeltas();
        if (deltas.length > 0) {
          collectionDeltas[collectionId] = deltas;
        }
      });
    } else {
      // For existing replicas, return only incremental deltas
      const replicaCollections =
        this.replicaTimestamps.get(replicaId) || new Map();

      this.collections.forEach((collection, collectionId) => {
        const replicaItems = replicaCollections.get(collectionId) || new Map();
        const deltas = collection.getDeltasSince(replicaItems);

        if (deltas.length > 0) {
          collectionDeltas[collectionId] = deltas;
        }
      });
    }

    if (Object.keys(collectionDeltas).length === 0) {
      return null;
    }

    return {
      documentId: this.documentId,
      collectionDeltas,
      fromReplica: "", // Will be set by caller
      fromAgent: "", // Will be set by caller
    };
  }

  /**
   * Merge a delta packet into this document
   */
  merge(packet: DocumentDeltaPacket<T>): DocumentMergeResult<T> {
    const applied: Record<CollectionId, CollectionDelta<T>[]> = {};
    const missing: Record<CollectionId, CollectionDelta<T>[]> = {};

    Object.entries(packet.collectionDeltas).forEach(
      ([collectionId, deltas]) => {
        const collection = this.getCollection(collectionId);
        const appliedDeltas = collection.applyDeltas(deltas);

        if (appliedDeltas.length > 0) {
          applied[collectionId] = appliedDeltas;

          // Update vector clocks for applied deltas
          appliedDeltas.forEach((delta: CollectionDelta<T>) => {
            this.updateVectorClock(
              collectionId,
              delta.itemId,
              delta.timestamp,
              delta.agentId,
              delta.replicaId
            );
          });
        }
      }
    );

    // Calculate missing deltas (what the sender doesn't have)
    this.collections.forEach((collection, collectionId) => {
      const senderAgent = packet.fromAgent;
      const senderCollections =
        this.agentTimestamps.get(senderAgent) || new Map();
      const senderItems = senderCollections.get(collectionId) || new Map();

      const missingDeltas = collection.getDeltasSince(senderItems);
      if (missingDeltas.length > 0) {
        missing[collectionId] = missingDeltas;
      }
    });

    return { applied, missing };
  }

  /**
   * Acknowledge that we sent deltas to an agent and they confirmed receipt
   * This updates our tracking of what the agent has seen
   * Call this after receiving merge result from the agent
   */
  acknowledgeMerge(
    agentId: AgentId,
    mergeResult: DocumentMergeResult<T>
  ): void {
    // Update tracking for all applied deltas - the agent now has these
    Object.entries(mergeResult.applied).forEach(([collectionId, deltas]) => {
      if (!this.agentTimestamps.has(agentId)) {
        this.agentTimestamps.set(agentId, new Map());
      }
      const agentCollections = this.agentTimestamps.get(agentId)!;
      if (!agentCollections.has(collectionId)) {
        agentCollections.set(collectionId, new Map());
      }
      const agentItems = agentCollections.get(collectionId)!;

      deltas.forEach((delta) => {
        const currentTimestamp = agentItems.get(delta.itemId);
        if (
          currentTimestamp === undefined ||
          delta.timestamp > currentTimestamp
        ) {
          agentItems.set(delta.itemId, delta.timestamp);
        }
      });
    });

    // Also update for missing deltas - the agent sent these in their original packet
    // so they definitely have them (they're "missing" from our perspective, not theirs)
    Object.entries(mergeResult.missing).forEach(([collectionId, deltas]) => {
      if (!this.agentTimestamps.has(agentId)) {
        this.agentTimestamps.set(agentId, new Map());
      }
      const agentCollections = this.agentTimestamps.get(agentId)!;
      if (!agentCollections.has(collectionId)) {
        agentCollections.set(collectionId, new Map());
      }
      const agentItems = agentCollections.get(collectionId)!;

      deltas.forEach((delta) => {
        const currentTimestamp = agentItems.get(delta.itemId);
        if (
          currentTimestamp === undefined ||
          delta.timestamp > currentTimestamp
        ) {
          agentItems.set(delta.itemId, delta.timestamp);
        }
      });
    });
  }

  /**
   * Acknowledge that we sent deltas to a replica and they confirmed receipt
   * This updates our tracking of what the replica has seen
   * Call this after receiving merge result from the replica
   */
  acknowledgeReplicaMerge(
    replicaId: ReplicaId,
    mergeResult: DocumentMergeResult<T>
  ): void {
    // Update tracking for all applied deltas - the replica now has these
    Object.entries(mergeResult.applied).forEach(([collectionId, deltas]) => {
      if (!this.replicaTimestamps.has(replicaId)) {
        this.replicaTimestamps.set(replicaId, new Map());
      }
      const replicaCollections = this.replicaTimestamps.get(replicaId)!;
      if (!replicaCollections.has(collectionId)) {
        replicaCollections.set(collectionId, new Map());
      }
      const replicaItems = replicaCollections.get(collectionId)!;

      deltas.forEach((delta) => {
        const currentTimestamp = replicaItems.get(delta.itemId);
        if (
          currentTimestamp === undefined ||
          delta.timestamp > currentTimestamp
        ) {
          replicaItems.set(delta.itemId, delta.timestamp);
        }
      });
    });

    // Also update for missing deltas - the replica sent these in their original packet
    // so they definitely have them (they're "missing" from our perspective, not theirs)
    Object.entries(mergeResult.missing).forEach(([collectionId, deltas]) => {
      if (!this.replicaTimestamps.has(replicaId)) {
        this.replicaTimestamps.set(replicaId, new Map());
      }
      const replicaCollections = this.replicaTimestamps.get(replicaId)!;
      if (!replicaCollections.has(collectionId)) {
        replicaCollections.set(collectionId, new Map());
      }
      const replicaItems = replicaCollections.get(collectionId)!;

      deltas.forEach((delta) => {
        const currentTimestamp = replicaItems.get(delta.itemId);
        if (
          currentTimestamp === undefined ||
          delta.timestamp > currentTimestamp
        ) {
          replicaItems.set(delta.itemId, delta.timestamp);
        }
      });
    });
  }

  /**
   * Get all deltas (entire document state)
   */
  getAllDeltas(): DocumentDeltaPacket<T> {
    const collectionDeltas: Record<CollectionId, CollectionDelta<T>[]> = {};

    this.collections.forEach((collection, collectionId) => {
      const deltas = collection.getAllDeltas();
      if (deltas.length > 0) {
        collectionDeltas[collectionId] = deltas;
      }
    });

    return {
      documentId: this.documentId,
      collectionDeltas,
      fromReplica: "",
      fromAgent: "",
    };
  }

  /**
   * Serialize to JSON
   */
  toJSON(): {
    documentId: DocumentId;
    collections: Record<CollectionId, ReturnType<Collection<T>["toJSON"]>>;
    agentTimestamps: Record<
      AgentId,
      Record<CollectionId, Record<ItemId, number>>
    >;
    replicaTimestamps: Record<
      ReplicaId,
      Record<CollectionId, Record<ItemId, number>>
    >;
  } {
    const collectionsObj: Record<
      CollectionId,
      ReturnType<Collection<T>["toJSON"]>
    > = {};
    this.collections.forEach((collection, collectionId) => {
      collectionsObj[collectionId] = collection.toJSON();
    });

    // Serialize agent timestamps
    const agentTimestampsObj: Record<
      AgentId,
      Record<CollectionId, Record<ItemId, number>>
    > = {};
    this.agentTimestamps.forEach((collections, agentId) => {
      agentTimestampsObj[agentId] = {};
      collections.forEach((items, collectionId) => {
        agentTimestampsObj[agentId][collectionId] = Object.fromEntries(items);
      });
    });

    // Serialize replica timestamps
    const replicaTimestampsObj: Record<
      ReplicaId,
      Record<CollectionId, Record<ItemId, number>>
    > = {};
    this.replicaTimestamps.forEach((collections, replicaId) => {
      replicaTimestampsObj[replicaId] = {};
      collections.forEach((items, collectionId) => {
        replicaTimestampsObj[replicaId][collectionId] =
          Object.fromEntries(items);
      });
    });

    return {
      documentId: this.documentId,
      collections: collectionsObj,
      agentTimestamps: agentTimestampsObj,
      replicaTimestamps: replicaTimestampsObj,
    };
  }

  /**
   * Deserialize from JSON
   */
  static fromJSON<T>(json: {
    documentId: DocumentId;
    collections: Record<CollectionId, any>;
    agentTimestamps: Record<
      AgentId,
      Record<CollectionId, Record<ItemId, number>>
    >;
    replicaTimestamps: Record<
      ReplicaId,
      Record<CollectionId, Record<ItemId, number>>
    >;
  }): Document<T> {
    const doc = new Document<T>(json.documentId);

    // Deserialize collections
    Object.entries(json.collections).forEach(
      ([collectionId, collectionData]) => {
        const collection = Collection.fromJSON<T>(collectionData);
        doc.collections.set(collectionId, collection);
      }
    );

    // Deserialize agent timestamps
    Object.entries(json.agentTimestamps).forEach(([agentId, collections]) => {
      const agentMap = new Map<CollectionId, Map<ItemId, number>>();
      Object.entries(collections).forEach(([collectionId, items]) => {
        agentMap.set(
          collectionId,
          new Map(Object.entries(items as Record<ItemId, number>))
        );
      });
      doc.agentTimestamps.set(agentId, agentMap);
    });

    // Deserialize replica timestamps
    Object.entries(json.replicaTimestamps).forEach(
      ([replicaId, collections]) => {
        const replicaMap = new Map<CollectionId, Map<ItemId, number>>();
        Object.entries(collections).forEach(([collectionId, items]) => {
          replicaMap.set(
            collectionId,
            new Map(Object.entries(items as Record<ItemId, number>))
          );
        });
        doc.replicaTimestamps.set(replicaId, replicaMap);
      }
    );

    return doc;
  }
}
